name: CI/CD Pipeline - EchoHub

on:
  push:
    branches: [ main, staging, development ]
  pull_request:
    branches: [ main, staging ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: echohub

jobs:
  test:
    name: üß™ Test & Lint
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: echohub_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4

    - name: üêò Setup PHP
      uses: shivammathur/setup-php@v2
      with:
        php-version: '8.3'
        extensions: mbstring, xml, ctype, iconv, intl, pdo_pgsql, dom, filter, gd, json, pgsql, bcmath, opcache

    - name: üì¶ Setup Node.js & PNPM
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: üîß Enable Corepack for PNPM
      run: corepack enable

    - name: üì¶ Cache Composer dependencies
      uses: actions/cache@v3
      with:
        path: ~/.composer/cache/files
        key: composer-${{ hashFiles('composer.lock') }}
        restore-keys: composer-

    - name: üì¶ Cache PNPM store
      uses: actions/cache@v3
      with:
        path: ~/.pnpm-store
        key: ${{ runner.os }}-pnpm-${{ hashFiles('pnpm-lock.yaml') }}
        restore-keys: ${{ runner.os }}-pnpm-

    - name: üîß Install PHP Dependencies
      run: composer install --no-interaction --prefer-dist --optimize-autoloader

    - name: üîß Install Node Dependencies
      run: pnpm install --no-frozen-lockfile

    - name: ‚öôÔ∏è Setup Test Environment
      run: |
        cp .env.example .env
        php artisan key:generate
        echo "DB_CONNECTION=pgsql" >> .env
        echo "DB_HOST=127.0.0.1" >> .env
        echo "DB_PORT=5432" >> .env
        echo "DB_DATABASE=echohub_test" >> .env
        echo "DB_USERNAME=postgres" >> .env
        echo "DB_PASSWORD=postgres" >> .env

    - name: üóÑÔ∏è Run Database Migrations
      run: php artisan migrate --force

    - name: üèóÔ∏è Build Frontend Assets
      run: SKIP_WAYFINDER=1 pnpm run build

    - name: üß™ Run PHP Tests
      run: vendor/bin/pest --coverage

    - name: üîç Run Linting
      run: pnpm run lint

    - name: üìù Run Type Checking
      run: pnpm run types

  build-and-deploy:
    name: üöÄ Build & Deploy
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging' || github.ref == 'refs/heads/development')
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4

    - name: üîß Set Environment Variables
      id: env
      run: |
        if [[ $GITHUB_REF == 'refs/heads/main' ]]; then
          echo "environment=production" >> $GITHUB_OUTPUT
          echo "domain=hub.echotravel.app" >> $GITHUB_OUTPUT
          echo "db_database=echohub_production" >> $GITHUB_OUTPUT
          echo "db_username=echohub_prod" >> $GITHUB_OUTPUT
          echo "app_debug=false" >> $GITHUB_OUTPUT
          echo "log_level=warning" >> $GITHUB_OUTPUT
        elif [[ $GITHUB_REF == 'refs/heads/staging' ]]; then
          echo "environment=staging" >> $GITHUB_OUTPUT
          echo "domain=staging-hub.echotravel.app" >> $GITHUB_OUTPUT
          echo "db_database=echohub_staging" >> $GITHUB_OUTPUT
          echo "db_username=echohub_staging" >> $GITHUB_OUTPUT
          echo "app_debug=true" >> $GITHUB_OUTPUT
          echo "log_level=debug" >> $GITHUB_OUTPUT
        else
          echo "environment=development" >> $GITHUB_OUTPUT
          echo "domain=dev-hub.echotravel.app" >> $GITHUB_OUTPUT
          echo "db_database=echohub" >> $GITHUB_OUTPUT
          echo "db_username=echohub" >> $GITHUB_OUTPUT
          echo "app_debug=true" >> $GITHUB_OUTPUT
          echo "log_level=debug" >> $GITHUB_OUTPUT
        fi

    - name: üîê Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: üê≥ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: üèóÔ∏è Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.env.outputs.environment }}-${{ github.sha }}
          ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.env.outputs.environment }}-latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
        labels: |
          org.opencontainers.image.source=${{ github.event.repository.html_url }}
          org.opencontainers.image.revision=${{ github.sha }}
          org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

    - name: üöÄ Deploy to VPS
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KEY }}
        script: |
          set -e
          
          # Environment variables
          export ENVIRONMENT="${{ steps.env.outputs.environment }}"
          export IMAGE_TAG="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.env.outputs.environment }}-${{ github.sha }}"
          export DOMAIN="${{ steps.env.outputs.domain }}"
          export APP_KEY="${{ secrets.APP_KEY }}"
          
          # Database configuration (using Dokploy PostgreSQL container)
          export DB_HOST="dokploy-postgres"
          export DB_DATABASE="${{ steps.env.outputs.db_database }}"
          export DB_USERNAME="${{ steps.env.outputs.db_username }}"
          
          # Environment-specific database password
          if [[ "$ENVIRONMENT" == "production" ]]; then
            export DB_PASSWORD="${{ secrets.DB_PASSWORD_PROD }}"
          elif [[ "$ENVIRONMENT" == "staging" ]]; then
            export DB_PASSWORD="${{ secrets.DB_PASSWORD_STAGING }}"
          else
            export DB_PASSWORD="${{ secrets.DB_PASSWORD_DEV }}"
          fi
          
          echo "üöÄ Deploying EchoHub to $ENVIRONMENT environment..."
          echo "üì¶ Image: $IMAGE_TAG"
          echo "üåê Domain: $DOMAIN"
          
          # Create deployment directory
          mkdir -p /opt/echohub-$ENVIRONMENT
          cd /opt/echohub-$ENVIRONMENT
          
          # Backup current deployment
          if [ -f docker-compose.yml ]; then
            echo "üì¶ Creating backup of current deployment..."
            cp docker-compose.yml docker-compose.yml.backup.$(date +%Y%m%d_%H%M%S)
          fi
          
          # Create optimized docker-compose.yml
          cat > docker-compose.yml << 'COMPOSE_EOF'
          version: '3.8'
          
          services:
            echohub:
              image: ${IMAGE_TAG}
              container_name: echohub-${ENVIRONMENT}
              restart: unless-stopped
              environment:
                - APP_NAME=EchoHub
                - APP_ENV=${ENVIRONMENT}
                - APP_KEY=${APP_KEY}
                - APP_DEBUG=${{ steps.env.outputs.app_debug }}
                - APP_URL=https://${DOMAIN}
                - LOG_LEVEL=${{ steps.env.outputs.log_level }}
                
                # Database Configuration
                - DB_CONNECTION=pgsql
                - DB_HOST=${DB_HOST}
                - DB_PORT=5432
                - DB_DATABASE=${DB_DATABASE}
                - DB_USERNAME=${DB_USERNAME}
                - DB_PASSWORD=${DB_PASSWORD}
                
                # AI Integration
                - MINERVA_AI_PROVIDER=ollama
                - MINERVA_AI_BASE_URL=http://ollama-service:11434
                - MINERVA_AI_MODEL=qwen2.5:3b
                
                # Performance (using file cache until Redis is setup)
                - CACHE_DRIVER=file
                - SESSION_DRIVER=file
                - QUEUE_CONNECTION=database
                
              networks:
                - dokploy-network
              
              labels:
                # Traefik Configuration (compatible with Dokploy's Traefik container)
                - "traefik.enable=true"
                - "traefik.http.routers.echohub-${ENVIRONMENT}.rule=Host(\`${DOMAIN}\`)"
                - "traefik.http.routers.echohub-${ENVIRONMENT}.entrypoints=websecure"
                - "traefik.http.routers.echohub-${ENVIRONMENT}.tls=true"
                - "traefik.http.routers.echohub-${ENVIRONMENT}.tls.certresolver=letsencrypt"
                - "traefik.http.services.echohub-${ENVIRONMENT}.loadbalancer.server.port=8000"
          
          networks:
            dokploy-network:
              external: true
          COMPOSE_EOF
          
          # Backup current deployment for rollback
          BACKUP_IMAGE=""
          if docker-compose ps echohub 2>/dev/null | grep -q "Up"; then
            echo "üì¶ Backing up current deployment for rollback..."
            BACKUP_IMAGE=$(docker inspect echohub-${ENVIRONMENT} --format='{{.Image}}' 2>/dev/null || echo "")
            echo "Backup image: $BACKUP_IMAGE"
          fi

          # Pull latest image
          echo "üì• Pulling latest image..."
          if ! docker-compose pull; then
            echo "‚ùå Failed to pull Docker image"
            echo "Check if image exists and registry is accessible"
            exit 1
          fi

          # Deploy with zero-downtime strategy
          echo "üîÑ Deploying with zero-downtime..."
          docker-compose up -d --remove-orphans

          # Wait for container to start
          echo "‚è≥ Waiting for container to start..."
          sleep 10

          # Check if container is running
          echo "üîç Checking container status..."
          MAX_WAIT=60
          ELAPSED=0
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            if docker-compose ps echohub 2>/dev/null | grep -q "Up"; then
              echo "‚úÖ Container is running"
              break
            fi

            if [ $ELAPSED -gt 30 ]; then
              echo "‚ö†Ô∏è  Container not up after ${ELAPSED}s, checking logs..."
              docker-compose ps
              docker-compose logs --tail=30 echohub
            fi

            sleep 5
            ELAPSED=$((ELAPSED + 5))
            echo "‚è≥ Waiting... (${ELAPSED}/${MAX_WAIT}s)"
          done

          if ! docker-compose ps echohub 2>/dev/null | grep -q "Up"; then
            echo "‚ùå Container failed to start after ${MAX_WAIT}s!"
            docker-compose ps
            docker-compose logs echohub

            # Rollback if we have a backup
            if [ -n "$BACKUP_IMAGE" ]; then
              echo "üîÑ Rolling back to previous version..."
              docker tag "$BACKUP_IMAGE" "$IMAGE_TAG"
              docker-compose up -d --force-recreate
            fi
            exit 1
          fi

          # Wait for application initialization
          echo "‚è≥ Waiting for application to initialize (migrations, cache, etc.)..."
          sleep 30

          # Internal health check first (bypass Traefik/network issues)
          echo "üè• Running internal health check..."
          INTERNAL_HEALTH_OK=false
          for i in {1..5}; do
            echo "üîÑ Internal check attempt $i/5..."
            if docker exec echohub-${ENVIRONMENT} curl -sf http://localhost:8000/up >/dev/null 2>&1; then
              echo "‚úÖ Internal health check passed"
              INTERNAL_HEALTH_OK=true
              break
            else
              echo "‚è≥ Application not ready, waiting 10s..."
              if [ $i -eq 3 ]; then
                echo "üìã Container logs:"
                docker-compose logs --tail=50 echohub
              fi
              sleep 10
            fi
          done

          if [ "$INTERNAL_HEALTH_OK" = false ]; then
            echo "‚ùå Internal health check failed - application not starting properly"
            echo "üìã Full logs:"
            docker-compose logs echohub
            echo "üîç Environment check:"
            docker exec echohub-${ENVIRONMENT} php artisan about || true

            # Rollback
            if [ -n "$BACKUP_IMAGE" ]; then
              echo "üîÑ Rolling back to previous version..."
              docker tag "$BACKUP_IMAGE" "$IMAGE_TAG"
              docker-compose up -d --force-recreate
            fi
            exit 1
          fi

          # External health check (through Traefik/domain)
          echo "üåê Running external health check through domain..."
          HEALTH_URL="https://$DOMAIN/up"
          echo "üîç Health check URL: $HEALTH_URL"

          EXTERNAL_HEALTH_OK=false
          for i in {1..12}; do
            echo "üîÑ External check attempt $i/12..."

            # Try curl with reasonable timeouts
            HTTP_CODE=$(curl -sf -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 30 "$HEALTH_URL" 2>/dev/null || echo "000")

            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ External health check passed (HTTP $HTTP_CODE)"
              EXTERNAL_HEALTH_OK=true
              break
            else
              echo "‚ö†Ô∏è  External check returned HTTP $HTTP_CODE"

              # Show diagnostics on early failures
              if [ $i -le 3 ]; then
                echo "üìù Container status:"
                docker-compose ps echohub
                echo "üîç Testing direct container access:"
                docker exec echohub-${ENVIRONMENT} curl -sf http://localhost:8000/up && echo "Direct access OK" || echo "Direct access failed"
              fi

              # Progressive backoff
              WAIT_TIME=$((10 + i * 3))
              echo "‚è≥ Waiting ${WAIT_TIME}s before next attempt..."
              sleep $WAIT_TIME
            fi
          done

          if [ "$EXTERNAL_HEALTH_OK" = false ]; then
            echo "‚ö†Ô∏è  External health check failed, but internal check passed"
            echo "This might be a Traefik/DNS/SSL issue, not the application"
            echo ""
            echo "üîç Diagnostics:"
            echo "1. Internal health: ‚úÖ OK"
            echo "2. External health: ‚ùå Failed"
            echo ""
            echo "üìã Troubleshooting steps:"
            echo "- Check Traefik configuration and logs"
            echo "- Verify DNS: dig $DOMAIN"
            echo "- Check SSL certificate"
            echo "- Verify dokploy-network connectivity"
            echo ""
            echo "üìã Recent logs:"
            docker-compose logs --tail=50 echohub
            echo ""
            echo "‚ö†Ô∏è  Deployment continuing since application is healthy internally"
            echo "Check TROUBLESHOOTING.md for network/Traefik issues"
          fi
          
          # Cleanup old containers and images
          echo "üßπ Cleaning up old resources..."
          docker system prune -f
          docker images | grep "${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}" | grep "$ENVIRONMENT" | tail -n +4 | awk '{print $3}' | xargs -r docker rmi
          
          echo "üéâ EchoHub $ENVIRONMENT deployed successfully!"
          echo "üåê Application URL: https://$DOMAIN"

    - name: ‚úÖ Deployment Success Notification
      if: success()
      run: |
        echo "üéâ Successfully deployed EchoHub to ${{ steps.env.outputs.environment }}"
        echo "üåê URL: https://${{ steps.env.outputs.domain }}"
        echo "üì¶ Image: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.env.outputs.environment }}-${{ github.sha }}"

    - name: ‚ùå Deployment Failure Notification
      if: failure()
      run: |
        echo "‚ùå Failed to deploy EchoHub to ${{ steps.env.outputs.environment }}"
        echo "üîç Check the logs above for details"